<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 手势交互粒子系统</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Arial', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* 摄像头预览 (左下角，镜像翻转) */
        .input_video { 
            position: absolute; bottom: 10px; left: 10px; width: 160px; height: 120px; 
            border-radius: 8px; border: 2px solid rgba(255,255,255,0.3); 
            z-index: 2; transform: scaleX(-1); opacity: 0.7;
        }

        /* 全屏按钮 */
        #fullscreen-btn {
            position: absolute; bottom: 20px; right: 20px; z-index: 10;
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3);
            color: white; padding: 10px 20px; cursor: pointer; border-radius: 4px;
            backdrop-filter: blur(5px); transition: 0.3s;
        }
        #fullscreen-btn:hover { background: rgba(255, 255, 255, 0.3); }

        /* 加载提示 */
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; z-index: 20; pointer-events: none;
            text-shadow: 0 0 10px rgba(0,255,255,0.8);
        }
    </style>
</head>
<body>

    <div id="loader">正在启动摄像头与模型...</div>
    <div id="canvas-container"></div>
    <video class="input_video" autoplay playsinline muted></video>
    <button id="fullscreen-btn">⛶ 全屏模式</button>

    <!-- 引入库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // ================= 配置与全局变量 =================
        const config = {
            particleCount: 15000,
            particleSize: 0.15,
            color: '#00ffff',
            model: 'Heart', // 默认模型
            textMessage: 'FUTURE',
            scaleBase: 1.0,
            spreadBase: 0.0,
            handInteraction: true
        };

        let scene, camera, renderer, particles, geometry;
        let targetPositions = []; // 目标形状的坐标数组
        let originalPositions = []; // 原始计算出的坐标
        const handData = { scale: 1, spread: 0, isDetected: false };

        // ================= Three.js 初始化 =================
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            // 添加一些雾化效果增加深度感
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // 创建粒子系统
            createParticleSystem();
            
            // 灯光 (虽然Points材质主要受顶点颜色影响，但加一点环境光)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            window.addEventListener('resize', onWindowResize);
            
            // 启动动画循环
            animate();
        }

        function createParticleSystem() {
            if (particles) scene.remove(particles);

            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(config.particleCount * 3);

            // 初始化所有点在中心
            for (let i = 0; i < config.particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 50; 
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: config.color,
                size: config.particleSize,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // 生成初始形状
            updateModelShape(config.model);
        }

        // ================= 形状生成算法 =================
        function getShapePositions(type) {
            const positions = [];
            const count = config.particleCount;

            if (type === 'Heart') {
                for (let i = 0; i < count; i++) {
                    const t = Math.random() * Math.PI * 2;
                    const r = Math.random(); // 填充内部
                    // 爱心公式
                    let x = 16 * Math.pow(Math.sin(t), 3);
                    let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    let z = (Math.random() - 0.5) * 5; // 增加一点厚度
                    
                    // 随机填充
                    const scale = Math.sqrt(Math.random()) * 0.8; 
                    positions.push(x * scale, y * scale, z * scale);
                }
            } 
            else if (type === 'Saturn') {
                for (let i = 0; i < count; i++) {
                    const r = Math.random();
                    // 70% 粒子做星球，30% 做光环
                    if (r > 0.3) {
                        // 球体
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos((Math.random() * 2) - 1);
                        const radius = 8;
                        positions.push(
                            radius * Math.sin(phi) * Math.cos(theta),
                            radius * Math.sin(phi) * Math.sin(theta),
                            radius * Math.cos(phi)
                        );
                    } else {
                        // 光环 (扁平的圆环)
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 12 + Math.random() * 6;
                        positions.push(
                            dist * Math.cos(angle),
                            (Math.random() - 0.5) * 1, // 环的厚度
                            dist * Math.sin(angle)
                        );
                    }
                }
            }
            else if (type === 'Flower') {
                for (let i = 0; i < count; i++) {
                    const u = Math.random() * Math.PI * 2; // 角度
                    const v = Math.random(); // 半径填充
                    // 玫瑰线 r = cos(k * theta)
                    const k = 4; // 花瓣数
                    const r = 15 * Math.cos(k * u) * v;
                    
                    positions.push(
                        r * Math.cos(u),
                        r * Math.sin(u),
                        (Math.random() - 0.5) * 4 // 厚度
                    );
                }
            }
            else if (type === 'Fireworks') {
                for (let i = 0; i < count; i++) {
                     // 随机球体分布，比较松散
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const radius = Math.random() * 20;
                    positions.push(
                        radius * Math.sin(phi) * Math.cos(theta),
                        radius * Math.sin(phi) * Math.sin(theta),
                        radius * Math.cos(phi)
                    );
                }
            }
            else if (type === 'Text') {
                return generateTextPositions(config.textMessage);
            }

            return positions;
        }

        // 文字生成辅助函数 (使用Canvas API读取像素)
        function generateTextPositions(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 100;
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 50px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const validPixels = [];

            for (let y = 0; y < canvas.height; y += 2) {
                for (let x = 0; x < canvas.width; x += 2) {
                    const i = (y * canvas.width + x) * 4;
                    if (data[i] > 128) { // 如果像素是亮的
                        validPixels.push({
                            x: (x - canvas.width / 2) * 0.3, // 缩放因子
                            y: -(y - canvas.height / 2) * 0.3, // Y轴反转
                            z: 0
                        });
                    }
                }
            }

            const positions = [];
            for (let i = 0; i < config.particleCount; i++) {
                // 随机从有效像素中取点，如果没有有效像素则随机分布
                if (validPixels.length > 0) {
                    const p = validPixels[i % validPixels.length];
                    positions.push(p.x, p.y, p.z + (Math.random()-0.5)*2);
                } else {
                    positions.push((Math.random()-0.5)*10, (Math.random()-0.5)*10, 0);
                }
            }
            return positions;
        }

        function updateModelShape(type) {
            config.model = type;
            const newPositions = getShapePositions(type);
            targetPositions = newPositions;
            // 如果是文字，粒子数量可能不匹配，需要重新填充或截断
            // 这里为了简单，我们让 animate 函数去处理平滑过渡，
            // 只需要确保 targetPositions 长度足够，不足的归零
            while (targetPositions.length < config.particleCount * 3) {
                targetPositions.push(0,0,0);
            }
        }

        // ================= UI 界面 =================
        function initGUI() {
            const gui = new lil.GUI({ title: '粒子控制面板' });
            
            gui.addColor(config, 'color').name('粒子颜色').onChange(c => {
                particles.material.color.set(c);
            });

            gui.add(config, 'particleSize', 0.01, 1).name('粒子大小').onChange(s => {
                particles.material.size = s;
            });

            const folderModels = gui.addFolder('模型选择');
            const models = ['Heart', 'Saturn', 'Flower', 'Text', 'Fireworks'];
            
            const modelConfig = { current: 'Heart' };
            folderModels.add(modelConfig, 'current', models).name('切换模型').onChange(val => {
                if (val !== 'Text') {
                    updateModelShape(val);
                } else {
                    updateModelShape('Text');
                }
            });

            const folderText = gui.addFolder('文字自定义');
            folderText.add(config, 'textMessage').name('文字内容').onFinishChange(() => {
                if(modelConfig.current === 'Text') updateModelShape('Text');
            });
            
            gui.add(config, 'handInteraction').name('启用手势控制');

            // 全屏按钮逻辑
            document.getElementById('fullscreen-btn').addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    if (document.exitFullscreen) document.exitFullscreen();
                }
            });
        }

        // ================= MediaPipe Hands 设置 =================
        function initMediaPipe() {
            const videoElement = document.getElementsByClassName('input_video')[0];
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            cameraUtils.start()
                .then(() => {
                    document.getElementById('loader').style.display = 'none';
                })
                .catch(err => {
                    console.error("Camera failed", err);
                    document.getElementById('loader').innerText = "摄像头启动失败，请检查权限";
                });
        }

        // 手势处理逻辑
        function onHandsResults(results) {
            if (!config.handInteraction) return;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handData.isDetected = true;
                const landmarks = results.multiHandLandmarks;

                // 1. 双手检测：控制缩放 (Scale)
                if (landmarks.length === 2) {
                    // 获取两只手食指指尖(ID:8)的距离
                    const p1 = landmarks[0][8];
                    const p2 = landmarks[1][8];
                    // 简单计算欧几里得距离
                    const dist = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                    
                    // 映射距离到缩放比例 (距离0.1~0.8 -> 缩放0.5~3.0)
                    // 注意：MediaPipe x坐标是归一化的0-1
                    let targetScale = (dist - 0.1) * 4; 
                    if(targetScale < 0.5) targetScale = 0.5;
                    if(targetScale > 4.0) targetScale = 4.0;
                    
                    // 平滑插值
                    handData.scale += (targetScale - handData.scale) * 0.1;
                    
                    // 双手时，松散度归零
                    handData.spread += (0 - handData.spread) * 0.1;
                }
                // 2. 单手检测：控制松散/炸裂 (Spread)
                else if (landmarks.length === 1) {
                    // 拇指(4) 和 食指(8) 的距离
                    const thumb = landmarks[0][4];
                    const index = landmarks[0][8];
                    const pinchDist = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));

                    // 捏合时(距离小)粒子聚合，张开时(距离大)粒子扩散
                    // 距离 0.05 ~ 0.3
                    let targetSpread = (pinchDist - 0.05) * 10; 
                    if (targetSpread < 0) targetSpread = 0;
                    if (targetSpread > 3) targetSpread = 3;

                    handData.spread += (targetSpread - handData.spread) * 0.1;
                    
                    // 单手时，缩放回归默认
                    handData.scale += (1.0 - handData.scale) * 0.1;
                }
            } else {
                handData.isDetected = false;
                // 无手势时回归默认
                handData.scale += (1.0 - handData.scale) * 0.05;
                handData.spread += (0 - handData.spread) * 0.05;
            }
        }

        // ================= 动画循环 =================
        function animate() {
            requestAnimationFrame(animate);

            if (!particles) return;

            const positions = particles.geometry.attributes.position.array;
            const time = Date.now() * 0.001;

            // 粒子运动更新
            for (let i = 0; i < config.particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // 目标位置
                const tx = targetPositions[ix] || 0;
                const ty = targetPositions[iy] || 0;
                const tz = targetPositions[iz] || 0;

                // 手势影响计算
                // Scale: 整体放大
                // Spread: 加上随机噪音，模拟扩散
                const noiseX = (Math.random() - 0.5) * 10 * handData.spread;
                const noiseY = (Math.random() - 0.5) * 10 * handData.spread;
                const noiseZ = (Math.random() - 0.5) * 10 * handData.spread;

                const finalTx = tx * handData.scale + noiseX;
                const finalTy = ty * handData.scale + noiseY;
                const finalTz = tz * handData.scale + noiseZ;

                // 缓动动画 (Lerp)
                positions[ix] += (finalTx - positions[ix]) * 0.05;
                positions[iy] += (finalTy - positions[iy]) * 0.05;
                positions[iz] += (finalTz - positions[iz]) * 0.05;
                
                // 添加微小的漂浮动画，让画面即使静止也很生动
                if (handData.spread < 0.2) {
                    positions[ix] += Math.sin(time + positions[iy] * 0.1) * 0.02;
                    positions[iy] += Math.cos(time + positions[ix] * 0.1) * 0.02;
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
            
            // 整体旋转
            particles.rotation.y += 0.002;
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ================= 启动 =================
        window.onload = () => {
            initThree();
            initGUI();
            initMediaPipe();
        };

    </script>
</body>
</html>
